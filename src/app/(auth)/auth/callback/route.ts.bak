/**
 * âš ï¸ DEPRECATED: Server Route â†’ Client Pageë¡œ ì´ê´€ë¨ (2025-10-23)
 *
 * ì´ìœ : ì´ë©”ì¼ ë³´ì•ˆ ìŠ¤ìºë„ˆ(Gmail, Outlook ë“±)ê°€ ë§í¬ë¥¼ ë¨¼ì € í´ë¦­í•˜ì—¬
 *       ì½”ë“œë¥¼ ì¡°ê¸° ì†Œëª¨í•˜ëŠ” ë¬¸ì œ ë°œìƒ
 *
 * í•´ê²°: /auth/callback/page.tsx (í´ë¼ì´ì–¸íŠ¸ í˜ì´ì§€)ë¡œ ì „í™˜
 *       â†’ ìŠ¤ìºë„ˆëŠ” JSë¥¼ ì‹¤í–‰í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì½”ë“œ ì†Œëª¨ ë°©ì§€
 *
 * ì´ íŒŒì¼ì€ ì°¸ê³ ìš©ìœ¼ë¡œ ë³´ê´€ë©ë‹ˆë‹¤.
 * ì„œë²„ ë¼ìš°íŠ¸ë¥¼ ë‹¤ì‹œ ì‚¬ìš©í•  ê²½ìš° ì•„ë˜ ë´‡ ê°ì§€ ë¡œì§ì„ ì ìš©í•˜ì„¸ìš”:
 *
 * @example
 * import { detectBotFromRequest, logBotDetection } from '@/lib/auth/bot-detection'
 *
 * export async function GET(request: Request) {
 *   // ë´‡ ê°ì§€
 *   const botResult = detectBotFromRequest(request)
 *   logBotDetection(botResult, { route: '/auth/callback' })
 *
 *   // ë´‡ì´ë©´ ì½”ë“œ êµí™˜í•˜ì§€ ì•Šê³  ì¡°ìš©íˆ ì‘ë‹µ
 *   if (botResult.isBot) {
 *     console.warn('[auth/callback] Bot detected, skipping code exchange')
 *     return new NextResponse(null, { status: 204 })
 *   }
 *
 *   // ì‹¤ì œ ì‚¬ìš©ìë§Œ ì½”ë“œ êµí™˜ ìˆ˜í–‰
 *   const code = url.searchParams.get('code')
 *   // ...
 * }
 */

import { createClient } from "@/lib/supabase/server"
import { NextResponse } from "next/server"
import { createUserProfileServer } from "@/app/actions/onboarding"

/**
 * Supabase ì¸ì¦ ì—ëŸ¬ë¥¼ ë¶„ì„í•˜ì—¬ ì ì ˆí•œ ì—ëŸ¬ íƒ€ì…ì„ ë°˜í™˜
 */
function classifyAuthError(error: { message?: string; code?: string }): string {
  const m = error.message?.toLowerCase() || ""
  const c = error.code?.toLowerCase() || ""

  if (m.includes("expired") || c.includes("expired")) return "expired"
  if (m.includes("already") || m.includes("used") || c.includes("consumed")) return "used"
  if (m.includes("invalid") || c.includes("invalid") || m.includes("not found")) return "invalid"
  if (m.includes("rate limit") || m.includes("too many")) return "rate_limit"
  if (m.includes("provider") || c.includes("provider")) return "provider_error"

  return "unknown"
}

/**
 * ì˜¨ë³´ë”© ìƒíƒœ ê¸°ë°˜ ë¦¬ë‹¤ì´ë ‰íŠ¸ URL ê³„ì‚°
 */
function getRedirectUrl(origin: string, stageCode?: string, nextUrl?: string, userEmail?: string): string {
  // 1. next_urlì´ ëª…ì‹œì ìœ¼ë¡œ ìˆìœ¼ë©´ ìš°ì„ 
  if (nextUrl) {
    return `${origin}${nextUrl}`
  }

  // 2. READY ìƒíƒœë©´ ëŒ€ì‹œë³´ë“œë¡œ
  if (stageCode === 'READY') {
    return `${origin}/dashboard`
  }

  // 3. ê¸°íƒ€ ìƒíƒœëŠ” ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ (í´ë¼ì´ì–¸íŠ¸ì—ì„œ ë‹¤ì‹œ ë¼ìš°íŒ…)
  const params = new URLSearchParams({ verified: 'true' })
  if (userEmail) {
    params.set('email', userEmail)
  }
  return `${origin}/auth/login?${params.toString()}`
}

export async function GET(request: Request) {
  const url = new URL(request.url)
  const requestId = crypto.randomUUID()

  // ğŸ” ë¡œê¹…: ì½œë°± ì§„ì… (ìŠ¤ìºë„ˆ ê°ì§€ìš©)
  console.log("[auth/callback] Request started:", {
    requestId,
    fullUrl: url.toString(),
    params: Object.fromEntries(url.searchParams),
    timestamp: new Date().toISOString(),
  })

  const code = url.searchParams.get("code")
  const type = (url.searchParams.get("type") || "signup").toLowerCase() // signup|recovery|invitation ë“±
  const origin = url.origin

  if (!code) {
    console.warn("[auth/callback] Missing code param", { requestId })
    return NextResponse.redirect(`${origin}/auth/login`)
  }

  const supabase = await createClient()
  const { error: exchangeErr } = await supabase.auth.exchangeCodeForSession(code)

  if (exchangeErr) {
    // ğŸ” ë¡œê¹…: êµí™˜ ì‹¤íŒ¨ (ìŠ¤ìºë„ˆê°€ ë¨¼ì € í˜¸ì¶œí–ˆëŠ”ì§€ í™•ì¸)
    console.error("[auth/callback] Session exchange failed:", {
      requestId,
      message: exchangeErr.message,
      status: exchangeErr.status,
      code: exchangeErr.code,
      name: exchangeErr.name,
    })
    const errType = classifyAuthError(exchangeErr)
    return NextResponse.redirect(`${origin}/auth/link-expired?type=${type}&error=${errType}`)
  }

  console.log("[auth/callback] Session exchange success", { requestId })

  // ì„¸ì…˜ êµí™˜ ì„±ê³µ â†’ í˜„ì¬ ì‚¬ìš©ì
  const {
    data: { user },
  } = await supabase.auth.getUser()

  if (!user) {
    console.error("[auth/callback] No user after session exchange", { requestId })
    return NextResponse.redirect(`${origin}/auth/login`)
  }

  const userId = user.id
  const userEmail = user.email || ""

  console.log("[auth/callback] User retrieved:", { requestId, userId, email: userEmail })

  // âœ… ì´ë©”ì¼ ì¸ì¦ í™•ì¸
  // Supabase v2: email_confirmed_at (v1ì—ì„  confirmed_at)
  const emailConfirmedAt = user.email_confirmed_at ?? (user as any).confirmed_at

  if (!emailConfirmedAt) {
    console.warn("[auth/callback] Email not confirmed yet", { requestId, userId })
    // ì´ë©”ì¼ ì¸ì¦ì´ ì•ˆ ë˜ì–´ ìˆìœ¼ë©´ verify-email í˜ì´ì§€ë¡œ
    return NextResponse.redirect(`${origin}/auth/verify-email?email=${encodeURIComponent(userEmail)}`)
  }

  // âœ… ìë™ í”„ë¡œí•„ ìƒì„± (SERVICE ROLE)
  // ì´ë©”ì¼ ì¸ì¦ ì§í›„ í”„ë¡œí•„ì´ ì—†ìœ¼ë©´ ìƒì„±í•©ë‹ˆë‹¤.
  try {
    const profileResult = await createUserProfileServer(userId)

    if (!profileResult.success) {
      console.error("[auth/callback] Profile creation failed:", {
        requestId,
        userId,
        error: profileResult.error,
      })
      // í”„ë¡œí•„ ìƒì„± ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ í˜ì´ì§€ë¡œ
      return NextResponse.redirect(`${origin}/auth/pending?error=profile_creation_failed`)
    }

    console.log("[auth/callback] Profile created/verified:", { requestId, userId })
  } catch (error) {
    console.error("[auth/callback] Profile creation exception:", {
      requestId,
      userId,
      error: error instanceof Error ? error.message : String(error),
    })
    // ì—ëŸ¬ê°€ ë°œìƒí•´ë„ ì‚¬ìš©ìë¥¼ pending í˜ì´ì§€ë¡œ ë³´ë‚´ì„œ ìˆ˜ë™ ì¬ì‹œë„ ê°€ëŠ¥í•˜ê²Œ í•¨
    return NextResponse.redirect(`${origin}/auth/pending?error=profile_creation_error`)
  }

  // âœ… ì˜¨ë³´ë”© ìƒíƒœ í™•ì¸ í›„ ì ì ˆí•œ í˜ì´ì§€ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸
  try {
    const { data: stageData, error: stageError } = await supabase.rpc('get_auth_stage', {
      p_invite_token: null,
    })

    if (stageError) {
      console.error("[auth/callback] get_auth_stage RPC failed:", {
        requestId,
        userId,
        error: stageError,
      })
      // Stage í™•ì¸ ì‹¤íŒ¨ ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ (í´ë¼ì´ì–¸íŠ¸ì—ì„œ ë‹¤ì‹œ í™•ì¸)
      const fallbackUrl = getRedirectUrl(origin, undefined, undefined, userEmail)
      return NextResponse.redirect(fallbackUrl)
    }

    const response = stageData as { ok: boolean; stage?: { code: string; next_url?: string } }

    if (!response?.ok || !response.stage) {
      console.warn("[auth/callback] Invalid stage response:", {
        requestId,
        userId,
        response,
      })
      const fallbackUrl = getRedirectUrl(origin, undefined, undefined, userEmail)
      return NextResponse.redirect(fallbackUrl)
    }

    const { code: stageCode, next_url: nextUrl } = response.stage

    console.log("[auth/callback] Auth stage determined:", {
      requestId,
      userId,
      stageCode,
      nextUrl: nextUrl || 'none',
    })

    // ì˜¨ë³´ë”© ìƒíƒœì— ë”°ë¼ ë¦¬ë‹¤ì´ë ‰íŠ¸
    const redirectUrl = getRedirectUrl(origin, stageCode, nextUrl, userEmail)

    console.log("[auth/callback] Redirecting to:", { requestId, userId, redirectUrl })

    return NextResponse.redirect(redirectUrl)
  } catch (error) {
    console.error("[auth/callback] Stage check exception:", {
      requestId,
      userId,
      error: error instanceof Error ? error.message : String(error),
    })
    // ì—ëŸ¬ ë°œìƒ ì‹œ ë¡œê·¸ì¸ í˜ì´ì§€ë¡œ
    const fallbackUrl = getRedirectUrl(origin, undefined, undefined, userEmail)
    return NextResponse.redirect(fallbackUrl)
  }
}
